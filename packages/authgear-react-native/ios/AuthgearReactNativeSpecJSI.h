/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeAuthgearReactNativeCxxSpecJSI : public TurboModule {
protected:
  NativeAuthgearReactNativeCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value storageGetItem(jsi::Runtime &rt, jsi::String key) = 0;
  virtual jsi::Value storageSetItem(jsi::Runtime &rt, jsi::String key, jsi::String value) = 0;
  virtual jsi::Value storageDeleteItem(jsi::Runtime &rt, jsi::String key) = 0;
  virtual jsi::Value getDeviceInfo(jsi::Runtime &rt) = 0;
  virtual jsi::Value randomBytes(jsi::Runtime &rt, double length) = 0;
  virtual jsi::Value sha256String(jsi::Runtime &rt, jsi::String input) = 0;
  virtual jsi::Value generateUUID(jsi::Runtime &rt) = 0;
  virtual jsi::Value openAuthorizeURL(jsi::Runtime &rt, jsi::String url, jsi::String callbackURL, bool prefersEphemeralWebBrowserSession) = 0;
  virtual jsi::Value openAuthorizeURLWithWebView(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value dismiss(jsi::Runtime &rt) = 0;
  virtual jsi::Value getAnonymousKey(jsi::Runtime &rt, std::optional<jsi::String> kid) = 0;
  virtual jsi::Value signAnonymousToken(jsi::Runtime &rt, jsi::String kid, jsi::String tokenData) = 0;
  virtual jsi::Value createBiometricPrivateKey(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value signWithBiometricPrivateKey(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value removeBiometricPrivateKey(jsi::Runtime &rt, jsi::String kid) = 0;
  virtual jsi::Value checkBiometricSupported(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value checkDPoPSupported(jsi::Runtime &rt, jsi::Object stub) = 0;
  virtual jsi::Value createDPoPPrivateKey(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value signWithDPoPPrivateKey(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value checkDPoPPrivateKey(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value computeDPoPJKT(jsi::Runtime &rt, jsi::Object options) = 0;

};

template <typename T>
class JSI_EXPORT NativeAuthgearReactNativeCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "AuthgearReactNative";

protected:
  NativeAuthgearReactNativeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAuthgearReactNativeCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

  template <typename OnAuthgearReactNativeType> void emitOnAuthgearReactNative(OnAuthgearReactNativeType value) {
    static_assert(bridging::supportsFromJs<OnAuthgearReactNativeType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onAuthgearReactNative"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

private:
  class Delegate : public NativeAuthgearReactNativeCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAuthgearReactNativeCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
      eventEmitterMap_["onAuthgearReactNative"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    }

    jsi::Value storageGetItem(jsi::Runtime &rt, jsi::String key) override {
      static_assert(
          bridging::getParameterCount(&T::storageGetItem) == 2,
          "Expected storageGetItem(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::storageGetItem, jsInvoker_, instance_, std::move(key));
    }
    jsi::Value storageSetItem(jsi::Runtime &rt, jsi::String key, jsi::String value) override {
      static_assert(
          bridging::getParameterCount(&T::storageSetItem) == 3,
          "Expected storageSetItem(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::storageSetItem, jsInvoker_, instance_, std::move(key), std::move(value));
    }
    jsi::Value storageDeleteItem(jsi::Runtime &rt, jsi::String key) override {
      static_assert(
          bridging::getParameterCount(&T::storageDeleteItem) == 2,
          "Expected storageDeleteItem(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::storageDeleteItem, jsInvoker_, instance_, std::move(key));
    }
    jsi::Value getDeviceInfo(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getDeviceInfo) == 1,
          "Expected getDeviceInfo(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getDeviceInfo, jsInvoker_, instance_);
    }
    jsi::Value randomBytes(jsi::Runtime &rt, double length) override {
      static_assert(
          bridging::getParameterCount(&T::randomBytes) == 2,
          "Expected randomBytes(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::randomBytes, jsInvoker_, instance_, std::move(length));
    }
    jsi::Value sha256String(jsi::Runtime &rt, jsi::String input) override {
      static_assert(
          bridging::getParameterCount(&T::sha256String) == 2,
          "Expected sha256String(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::sha256String, jsInvoker_, instance_, std::move(input));
    }
    jsi::Value generateUUID(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::generateUUID) == 1,
          "Expected generateUUID(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::generateUUID, jsInvoker_, instance_);
    }
    jsi::Value openAuthorizeURL(jsi::Runtime &rt, jsi::String url, jsi::String callbackURL, bool prefersEphemeralWebBrowserSession) override {
      static_assert(
          bridging::getParameterCount(&T::openAuthorizeURL) == 4,
          "Expected openAuthorizeURL(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openAuthorizeURL, jsInvoker_, instance_, std::move(url), std::move(callbackURL), std::move(prefersEphemeralWebBrowserSession));
    }
    jsi::Value openAuthorizeURLWithWebView(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openAuthorizeURLWithWebView) == 2,
          "Expected openAuthorizeURLWithWebView(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openAuthorizeURLWithWebView, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value dismiss(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::dismiss) == 1,
          "Expected dismiss(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::dismiss, jsInvoker_, instance_);
    }
    jsi::Value getAnonymousKey(jsi::Runtime &rt, std::optional<jsi::String> kid) override {
      static_assert(
          bridging::getParameterCount(&T::getAnonymousKey) == 2,
          "Expected getAnonymousKey(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getAnonymousKey, jsInvoker_, instance_, std::move(kid));
    }
    jsi::Value signAnonymousToken(jsi::Runtime &rt, jsi::String kid, jsi::String tokenData) override {
      static_assert(
          bridging::getParameterCount(&T::signAnonymousToken) == 3,
          "Expected signAnonymousToken(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::signAnonymousToken, jsInvoker_, instance_, std::move(kid), std::move(tokenData));
    }
    jsi::Value createBiometricPrivateKey(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::createBiometricPrivateKey) == 2,
          "Expected createBiometricPrivateKey(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::createBiometricPrivateKey, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value signWithBiometricPrivateKey(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::signWithBiometricPrivateKey) == 2,
          "Expected signWithBiometricPrivateKey(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::signWithBiometricPrivateKey, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value removeBiometricPrivateKey(jsi::Runtime &rt, jsi::String kid) override {
      static_assert(
          bridging::getParameterCount(&T::removeBiometricPrivateKey) == 2,
          "Expected removeBiometricPrivateKey(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeBiometricPrivateKey, jsInvoker_, instance_, std::move(kid));
    }
    jsi::Value checkBiometricSupported(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::checkBiometricSupported) == 2,
          "Expected checkBiometricSupported(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::checkBiometricSupported, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value checkDPoPSupported(jsi::Runtime &rt, jsi::Object stub) override {
      static_assert(
          bridging::getParameterCount(&T::checkDPoPSupported) == 2,
          "Expected checkDPoPSupported(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::checkDPoPSupported, jsInvoker_, instance_, std::move(stub));
    }
    jsi::Value createDPoPPrivateKey(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::createDPoPPrivateKey) == 2,
          "Expected createDPoPPrivateKey(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::createDPoPPrivateKey, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value signWithDPoPPrivateKey(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::signWithDPoPPrivateKey) == 2,
          "Expected signWithDPoPPrivateKey(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::signWithDPoPPrivateKey, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value checkDPoPPrivateKey(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::checkDPoPPrivateKey) == 2,
          "Expected checkDPoPPrivateKey(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::checkDPoPPrivateKey, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value computeDPoPJKT(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::computeDPoPJKT) == 2,
          "Expected computeDPoPJKT(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::computeDPoPJKT, jsInvoker_, instance_, std::move(options));
    }

  private:
    friend class NativeAuthgearReactNativeCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
